#!/usr/bin/env python3
#
# Repository:  https://github.com/kingkybel/FixDecoder
# File Name:   scripts/generate_fix_decoder_maps.py
# Description: Generate per-standard header maps from FIX tag number to decoder tag.
#
# Copyright (C) 2026 Dieter J Kybelksties <github@kybelksties.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
# @date: 2026-02-11
# @author: Dieter J Kybelksties
#

import pathlib
import re
import sys
import xml.etree.ElementTree as ET


def decoder_tag(field_type: str) -> str:
    int_types = {"INT", "LENGTH", "SEQNUM", "NUMINGROUP"}
    float_types = {"FLOAT"}
    double_types = {"AMT", "PRICE", "PRICEOFFSET", "QTY", "PERCENTAGE"}
    bool_types = {"BOOLEAN"}
    raw_types = {"DATA"}

    t = (field_type or "").upper()
    if t in bool_types:
        return "kBool"
    if t in int_types:
        return "kGroupCount" if t == "NUMINGROUP" else "kInt64"
    if t in float_types:
        return "kFloat"
    if t in double_types:
        return "kDouble"
    if t in raw_types:
        return "kRawData"
    if t:
        return "kString"
    return "kUnknown"


def to_guard(stem: str) -> str:
    return "FIXDECODER_GENERATED_" + re.sub(r"[^A-Za-z0-9]", "_", stem.upper()) + "_DECODER_MAP_H_INCLUDED"


def to_namespace(stem: str) -> str:
    return re.sub(r"[^A-Za-z0-9]", "_", stem.lower())


def to_field_enum_name(field_name: str, tag_number: int) -> str:
    cleaned = re.sub(r"[^A-Za-z0-9]", "_", (field_name or "").strip())
    cleaned = re.sub(r"_+", "_", cleaned).strip("_")
    if not cleaned:
        cleaned = f"Tag_{tag_number}"
    if cleaned[0].isdigit():
        cleaned = "Tag_" + cleaned
    return "k" + cleaned[0].upper() + cleaned[1:]


def begin_string(root) -> str:
    fix_type = root.attrib.get("type", "FIX")
    major = root.attrib.get("major", "0")
    minor = root.attrib.get("minor", "0")
    prefix = "FIXT" if fix_type == "FIXT" else "FIX"
    return f"{prefix}.{major}.{minor}"


def write_decoder_tag_header(out_dir: pathlib.Path) -> None:
    enum_header = out_dir / "decoder_tag.h"
    enum_header.write_text(
        """/*
 * AUTO-GENERATED FILE. DO NOT EDIT.
 * Generated by scripts/generate_fix_decoder_maps.sh
 */

#ifndef FIXDECODER_GENERATED_DECODER_TAG_H_INCLUDED
#define FIXDECODER_GENERATED_DECODER_TAG_H_INCLUDED

#include <cstdint>

namespace fix::generated
{

enum class DecoderTag : std::uint8_t
{
    kUnknown = 0,
    kBool,
    kInt64,
    kFloat,
    kDouble,
    kString,
    kGroupCount,
    kRawData
};

}  // namespace fix::generated

#endif  // FIXDECODER_GENERATED_DECODER_TAG_H_INCLUDED
""",
        encoding="utf-8",
    )


def write_per_dictionary_header(xml_file: pathlib.Path, out_dir: pathlib.Path) -> None:
    tree = ET.parse(xml_file)
    root = tree.getroot()
    fields = root.find("fields")
    tag_map = {}
    tag_name_map = {}
    used_enum_names = set()

    if fields is not None:
        for field in fields.findall("field"):
            number_text = field.attrib.get("number")
            if not number_text:
                continue
            try:
                tag_number = int(number_text)
            except ValueError:
                continue
            tag_map[tag_number] = decoder_tag(field.attrib.get("type", ""))
            enum_name = to_field_enum_name(field.attrib.get("name", ""), tag_number)
            if enum_name in used_enum_names:
                enum_name = f"{enum_name}_{tag_number}"
            used_enum_names.add(enum_name)
            tag_name_map[tag_number] = enum_name

    stem = xml_file.stem
    guard = to_guard(stem)
    ns = to_namespace(stem)
    bs = begin_string(root)
    out_file = out_dir / f"{stem}_decoder_map.h"

    enum_entries = "\n".join(f"    {enum_name} = {tag}," for tag, enum_name in sorted(tag_name_map.items()))
    entries = "\n".join(
        f"    {{static_cast<std::uint32_t>(FieldTag::{tag_name_map[tag]}), DecoderTag::{tag_kind}}},"
        for tag, tag_kind in sorted(tag_map.items())
    )

    out_file.write_text(
        f"""/*
 * AUTO-GENERATED FILE. DO NOT EDIT.
 * Source: {xml_file.name}
 * BeginString: {bs}
 * Generated by scripts/generate_fix_decoder_maps.sh
 */

#ifndef {guard}
#define {guard}

#include "decoder_tag.h"

#include <cstdint>
#include <unordered_map>

namespace fix::generated::{ns}
{{

inline constexpr const char *kDictionaryName = "{stem}";
inline constexpr const char *kBeginString = "{bs}";

enum class FieldTag : std::uint32_t
{{
{enum_entries}
}};

inline const std::unordered_map<std::uint32_t, DecoderTag> kTagToDecoderTag = {{
{entries}
}};

inline DecoderTag decoderTagFor(const std::uint32_t tag)
{{
    const auto it = kTagToDecoderTag.find(tag);
    if(it == kTagToDecoderTag.end())
    {{
        return DecoderTag::kUnknown;
    }}
    return it->second;
}}

}}  // namespace fix::generated::{ns}

#endif  // {guard}
""",
        encoding="utf-8",
    )


def main() -> int:
    if len(sys.argv) != 3:
        print("Usage: generate_fix_decoder_maps.py <xml_dir> <out_dir>", file=sys.stderr)
        return 1

    xml_dir = pathlib.Path(sys.argv[1])
    out_dir = pathlib.Path(sys.argv[2])
    out_dir.mkdir(parents=True, exist_ok=True)

    xml_files = sorted(xml_dir.glob("*.xml"))
    if not xml_files:
        print(f"No XML files found in {xml_dir}", file=sys.stderr)
        return 1

    write_decoder_tag_header(out_dir)
    for xml_file in xml_files:
        write_per_dictionary_header(xml_file, out_dir)

    print(f"Generated {len(xml_files)} map header(s) in {out_dir}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
